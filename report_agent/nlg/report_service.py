import logging
import sys
from pathlib import Path
from typing import Sequence

from report_agent.metrics.metrics_loader import MetricsLoader
from report_agent.metrics.metrics_registry import MetricsRegistry
from report_agent.nlg.html_report import render_html_report

log = logging.getLogger(__name__)


def generate_html_report(
    model: str,
    connector,                   
    out_dir: str = "reports",
    plots_subdir: str = "plots",
    data_subdir: str = "data",
    text_subdir: str = "text",
    plots_index_subdir: str = "plots_index",
) -> str:
    """
    Run the interpreter, download plots, save CSV and narrative text, and write an HTML report.

    Returns the HTML file path as a string.

    Side effects (under `out_dir`):
      - plots/<...>.png           – plots generated by the CI container
      - data/<model>.csv          – raw time series or snapshot table
      - text/<model>.txt          – plain-text narrative from the LLM
      - plots_index/<model>.txt   – list of plot file paths for this metric
      - <date>_<model>.html       – rendered HTML report
    """
    out_root = Path(out_dir)
    out_root.mkdir(parents=True, exist_ok=True)

    narrative = connector.run_report(model)

    text_dir = out_root / text_subdir
    text_dir.mkdir(parents=True, exist_ok=True)
    text_path = text_dir / f"{model}.txt"
    text_path.write_text(narrative, encoding="utf-8")

    plots_dir_path = out_root / plots_subdir
    plots_dir_path.mkdir(parents=True, exist_ok=True)
    saved = connector.download_artifacts(output_dir=str(plots_dir_path))
    image_paths: Sequence[str] = [
        p
        for p in saved
        if not str(p).startswith("ERROR:")
        and str(p).lower().endswith((".png", ".jpg", ".jpeg", ".gif"))
    ]

    # Validate plot generation - warn if no plots were generated
    if not image_paths:
        log.warning(f"⚠ No plots generated for metric '{model}'. Expected at least Figure 1 (headline weekly trend).")
        print(f"  ⚠ WARNING: No plots generated for {model}. The LLM should have created at least Figure 1.", file=sys.stderr)
    else:
        log.info(f"✓ Generated {len(image_paths)} plot(s) for metric '{model}'")
        if len(image_paths) == 1:
            log.info(f"  Note: Only 1 plot generated. Expected 2 plots (Figure 1 mandatory, Figure 2 if segments exist).")

    plots_index_dir = out_root / plots_index_subdir
    plots_index_dir.mkdir(parents=True, exist_ok=True)
    plots_index_path = plots_index_dir / f"{model}.txt"
    if image_paths:
        plots_index_path.write_text("\n".join(str(p) for p in image_paths), encoding="utf-8")
    else:
        plots_index_path.write_text("", encoding="utf-8")

    # Try to reuse the dataframe that was already fetched for LLM processing
    # This avoids duplicate database queries
    df = None
    if hasattr(connector, "get_last_dataframe"):
        df = connector.get_last_dataframe(model)
    
    # If dataframe not available from connector, fetch it (backward compatible)
    if df is None:
        reg = MetricsRegistry()
        kind = reg.get_kind(model)
        
        loader = MetricsLoader()
        if kind == "time_series":
            hist = reg.get_history_days(model)
            df = loader.fetch_time_series(model, lookback_days=hist)
        else:
            df = loader.fetch_snapshot(model)

    data_dir = out_root / data_subdir
    data_dir.mkdir(parents=True, exist_ok=True)
    data_path = data_dir / f"{model}.csv"
    df.to_csv(data_path, index=False)

    html_path = render_html_report(
        model=model,
        narrative_markdown=narrative,
        image_paths=[str(Path(p)) for p in image_paths],
        data_csv_path=str(data_path),
        out_dir=str(out_root),
    )
    return html_path